今天完成的事情：

linux
logout/exit 退出/注销

shutdown 关机
shutdown -h 带时间条件的关机 (服务器关机是非常危险的行为，谨慎操作)
shutdown -h now  立刻关机  需要授权或root帐号操作
shutdown -h 12.30 指定具体时间关机
shutdown -h 3   3分钟后关机

sudo : superuser do  : 超级用户来执行该命令
由超级用户配置谁可以执行sudo,不然岂不是任何账户都可以用sudo来执行一些高危操作
配置到 /etc/sudoers ,该文件有所有用户的权限设置
cat /etc/sudoers 查看权限内容 cat : 查看

shutdown -r 时间  ： 指定时间后重启
    -r :  restart

linux基本命令：文件操作命令
1.
ls ：查看目录内容
  -l:查看详细信息
  -a:查看所有文件(包括隐藏文件)
    演示：
	如下图，在根目录输入ls，只是简单的显示所有文件
	@1
	输入ls -l，则以详细列表的形式展现
	@2
	ls -a，显示的结果比单纯的ls多了两个隐藏文件，如红框中所示
	@3
	也可以组合使用，ls -al(或 -la)，会将所有文件(包括隐藏)以列表形式展出
	@4
man : manual 手册、指南的意思，帮助命令，好比windows的help
如 man ls 显示ls下的所有分支命令
@5
2.
mkdir : 创建目录
  mkdir opt 创建opt文件夹
  cd opt 进入了该文件夹
  cd .. 返回了上一级目录(我的是root)
  mkdir ./opt/java 在当前目录下的opt里创建java文件夹
  然后进去一看果然创建了java文件夹，如下
  @6
3.
cd 进入目录
  -cd .. 返回上一目录
  -cd ./子目录/子目录  直接进到孙目录，再往后加可以进到曾孙目录
  @7
  -cd ../../  进入爷爷目录
  -cd ../../../home, 进入曾祖父目录下的home目录，前提是该目录下有home目录
  @8
  -cd ../../../home/avi/jpn, 进入曾祖父的儿子home的儿子avi的儿子jpn目录里，就是进入曾祖父的曾孙jpn里，如果有这个曾孙的话。(顺便还把中国的族谱关系理了一下)
4.
touch : 创建一个空白的普通文件
比如touch aa.txt, 就是创建了一个aa.txt,里面什么内容都没有。
5.
echo : 
比如输入 echo "操你妈">bb.txt ,就会把"操你妈"放到bb.txt里，没有该txt就创建一个。
代码演示如下
@9
6.
cat : 查看文件内容
more : 分页查看文件内容
	这个分页的意思就是说，比如你 more bb.txt,假设里面有一千句"操你妈",显然你用cat一页是显示不全的
	用more可以分页显示，然后按空格换页。
7.
cp : 复制
比如在root目录下，执行 cp bb.txt ./opt/java，就是把root下的bb.txt复制到了java下。
你也可以在root下，直接执行 ls ./opt/java，这样可以直接查看到它孙子java下的目录内容，比如我们刚刚
复制过去的bb.txt.

mv :
1.剪切
2.重命名
-比如在root目录下，执行 mv bb.txt ../home，就是把root下的bb.txt剪切到了爸爸的另一个儿子home下。
 然后在执行 ls ../home, 就可以查看有没有剪切成功
-如果剪切的文件存放在同一目录中，则是重命名。
 比如 mv bb.txt cc.txt ,就是将bb重命名为cc

rm
	-删除文件
rm -f 
     -强制删除，没有提示，也不管是否存在这个文件，就是删
	 如 rm -f aa.txt 没存在也不要紧，就是删，没有任何提示
rm -i
	-删除前提示 ，默认不删除，要删除，输入y
rm -d
	-删除空白目录
rm -r
	-递归删除,删除一个文件夹里所有的子子孙孙。

pwd 查看当前目录绝对路径
   
重定向
    - > :覆盖模式
	比如 echo "操你爸">bb.txt , 然后该文件原内容就被"操你爸"覆盖了。
	- >>：追加模式
	 就是没有覆盖，而是在原基础上加内容。 
passwd   :设置密码  ，ubuntu默认 root账号是没有开启 ，只要设置root密码即可开启
         执行 sudo passwd root, 是为root账户设置密码
su  切换用户

——————————————————————————————————————————————————————————————————————————————————————————
(重点)

1.安装软件：
正如windows的软件都是 *.exe ,ubuntu是对debian的升级版，所以软件是*.deb 格式
离线安装
  dpkg : debian package的意思
  执行 sudo dpkg -i <文件名> ,即可安装已经下载好的文件。
    -i : install
  卸载
  执行 sudo dpkg -r <包名>, 即可卸载, 比如sudo dpkg -r mysql
     -r : remove
在线安装
	apt-get : advance package tools, 是对dpkg命令的升级，在线安装
	执行：sudo apt-get -install <包名>,  安装
	执行：sudo apt-get -remove <包名>,  卸载
2.vim 软件:类似记事本，但比记事本强大
 首先输入vim回车，如果能进入就代表有预装vim，没有预装还要下载，我的是有预装的。
 
 使用vim 
   执行 vim aa.txt ,就可以对该文件进行编辑了。  
   操作模式：
	 1. 一般模式 ，默认进入的一般模式，该模式不能编辑文档 ，只能查看
		按 i（insert）  进入 插入模式 
	 2. 编辑模式、插入模式 
		 该模式可以编辑文档，按esc 退出插入模式，进入到一般模式 
	 3. 命令模式 ：在 一般模式中按：进入命令模式
		- q： 安全退出，当没有操作该文档，则直接按q退出vim 
	- q! ：当修改了内容，但是不想保存，则q！强制退出
	- wq ：保存退出
	- set number 显示行号
	- set nonumber 取消行号显示	
	




——————————————————————————————————————————————————————————————————————————————————————————————————————————————

| 管道命令
前面命令的结果作为后面命令的输入，因为默认它是输入到屏幕的。


ps  Process Status

用ps命令参数 进程查看命令
需掌握一些最常用的命令参数就可以了。
最常用的三个参数是u、a、x。
a 显示终端上的所有进程，包括其他用户的进程。
x 显示没有控制终端的进程
u user 用户名

-f 全部列出，通常和其他选项联用。如：ps -fa or ps -fx and so on.

组合使用ps axuf


ps aux 和ps -ef 比较
两者的输出结果差别不大，但展示风格不同。aux是BSD风格，-ef是System V风格。这是次要的区别，一个影响使用的区别是aux会截断command列，而-ef不会。
当结合grep时这种区别会影响到结果。 
举例请参考：http://www.2cto.com/os/201303/197697.html 

综上：以上三个命令推荐使用：ps –ef 


-------------------------------------------------------------------------


在linux中，&和&&,|和||介绍如下：

&  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &

&& &&前的命令执行成功了就继续执行后面的命令 ， 如 echo '1‘ && echo '2'    

| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo 'yes' | wc -l

||  ||前的命令执行失败了就去执行后面的命令，如 cat nofile || echo "fail"


-----------------------------------------------------------------------------

` 的意思
在字符1左边，在TAB键上面的那个键，引住的命令（command）执行结果能赋值给一个变量。
例子：
A=`ls -l`
把ls -l的结果赋给A    ls -l 作为命令来执行


$()与 ``

在操作上，这两者都是达到相应的效果，但是建议使用$( )，理由如下：

    ｀｀很容易与''搞混乱，尤其对初学者来说。
    在多层次的复合替换中，｀｀必须要额外的跳脱处理（反斜线），而$( )比较直观。
    最后，$( )的弊端是，并不是所有的类unix系统都支持这种方式，但反引号是肯定支持的
	
	
 ${}变量替换

一般情况下，$var与${var}是没有区别的，但是用${ }会比较精确的界定变量名称的范围

--------------------------------------------------------------------------------
1.grep 是查找含有指定文本行的意思，比如grep test 就是查找含有test的文本的行

2.grep -v 是反向查找的意思，比如 grep -v grep 就是查找不含有 grep 字段的行

---------------------------------------------------------------------------------

2> 1> 0>

  标准输入，标准输出，标准错误其实是三个完全不同的文件，虽然我们看起来标准输出和标准错误都输入到显示屏中显示，但是不能用输出重定向将错误重定向到其他文件
  标准输入，标准输出，标准错误的文件描述符分别是0，1，2，这也是错误重定向2>的由来

--------------------------------------------------------------------------------
echo -n 和echo -e 参数意义

echo -n 不换行输出

$echo -n "123"
$echo "456"

最终输出 
123456

而不是
123
456


echo -e 处理特殊字符

若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：
\a 发出警告声；
\b 删除前一个字符；
\c 最后不加上换行符号；
\f 换行但光标仍旧停留在原来的位置；
\n 换行且光标移至行首；
\r 光标移至行首，但不换行；
\t 插入tab；
\v 与\f相同；
\ 插入\字符；
\nnn 插入nnn（八进制）所代表的ASCII字符；

$echo -e "a\bdddd"
dddd


$echo -e "a\adddd" //输出同时会发出报警声音
adddd


$echo -e "a\ndddd" //自动换行
a
dddd  

----------------------------------------------------------------------------------
if [ str1 = str2 ]　　　　　  当两个串有相同内容、长度时为真 
if [ str1 != str2 ]　　　　　 当串str1和str2不等时为真 
if [ -n str1 ]　　　　　　 当串的长度大于0时为真(串非空) 
if [ -z str1 ]　　　　　　　 当串的长度为0时为真(空串) 
if [ str1 ]　　　　　　　　 当串str1为非空时为真

shell 中利用 -n 来判定字符串非空。

-------------------------------------------------------------------

kill和kill -9

kill 会等待进程释放完资源在结束进程
kill -9 是直接退出

---------------------------------------------------
 grep命令常见用法

在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行：

grep match_pattern file_name
grep "match_pattern" file_name

在多个文件中查找：

grep "match_pattern" file_1 file_2 file_3 ...

输出除之外的所有行 -v 选项：

grep -v "match_pattern" file_name

标记匹配颜色 --color=auto 选项：

grep "match_pattern" file_name --color=auto

使用正则表达式 -E 选项：

grep -E "[1-9]+"
或
egrep "[1-9]+"

只输出文件中匹配到的部分 -o 选项：

echo this is a test line. | grep -o -E "[a-z]+\."
line.

echo this is a test line. | egrep -o "[a-z]+\."
line.
